# 1번

###### 문제 설명

5지선다 OMR 답안지를 이용하는 어떤 모의고사가 있습니다. 당신은 그 모의고사의 OMR 답안지와 실제 정답지를 받았습니다. 이때, 당신은 그 모의고사의 OMR 답안지의 일부분을 "밀려 쓰기"로 인정하여 해당 부분의 답안을 앞당겨서 채점을 하려고 합니다.

예를 들어, 다음과 같은 상황을 가정해봅시다.

| 문제 번호  | 1번  | 2번  | 3번  | 4번  | 5번  | 6번  |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 정답지     | 2    | 4    | 1    | 5    | 2    | 3    |
| OMR 답안지 | 2    | 3    | 4    | 5    | 5    | 3    |

이 답안지를 정상적으로 채점한다면, 이 답안지를 작성한 사람이 맞은 문제는 2개입니다. 하지만, 만약 당신이 이 답안지의 A번부터의 영역을 밀려 쓰기로 인정한다면,

1. 기존의 A번 문제의 마킹을 삭제하고,
2. A+1번 문제부터 맨 마지막 문제까지의 마킹을 한 칸 앞으로 당기고
3. 맨 마지막 문제는 공란(마킹을 하지 않았다는 뜻)으로 표시한 뒤

채점을 하게 됩니다. 다음 표는 위 답안지의 2번부터의 영역을 밀려쓰기로 인정한 뒤 위의 과정을 거쳐 채점한 상황을 나타낸 것입니다.

| 문제 번호             | 1번  | 2번       | 3번       | 4번       | 5번       | 6번  | 맞춘 문제 개수             |
| --------------------- | ---- | --------- | --------- | --------- | --------- | ---- | -------------------------- |
| 정답지                | 2    | 4         | 1         | 5         | 3         | 3    |                            |
| 원래 OMR 답안지       | 2    | 3         | 4         | 5         | 5         | 3    | 3문제 (1번, 4번, 6번)      |
| 2번부터 밀려쓰기 인정 | 2    | ~~3~~ → 4 | ~~4~~ → 5 | ~~5~~ → 5 | ~~5~~ → 3 | 공란 | 4문제 (1번, 2번, 4번, 5번) |

이제 이 OMR 답안지는 4문제를 맞힌 답안지가 되었습니다. 2번부터의 영역을 밀려 쓰기로 인정했을 때 이 답안지는 가장 많은 점수를 받습니다. 주어진 답안지를 5문제 이상 맞게 하는 다른 방법은 없습니다.

OMR 답안지의 내용을 나타내는 marks, 정답지의 내용을 나타내는 answers가 매개변수로 주어집니다. 이 답안지를 그대로 채점하거나, 또는 적절한 영역을 딱 한번 골라 해당 영역을 밀려 쓰기로 인정하고 앞당겨서 채점했을 때, 가능한 한 최대로 맞출 수 있는 문제 개수를 return 하도록 solution 함수를 완성해주세요.

------

##### 제한 사항

- marks의 길이는 2 이상 100 이하입니다.
  - marks는 1 이상 5 이하의 자연수들로 구성된 배열입니다.
  - `marks[i]`는 OMR 답안지에서 i+1 번째 문제에 마킹된 번호를 의미합니다.
- answers의 길이는 marks의 길이와 같습니다.
  - answers는 1 이상 5 이하의 자연수들로 구성된 배열입니다.
  - `answers[i]`는 i+1 번째 문제의 정답을 의미합니다.

------

##### 입출력 예

| marks           | answers         | result |
| --------------- | --------------- | ------ |
| `[2,3,4,5,5,3]` | `[2,4,1,5,3,3]` | 4      |
| `[1,3,5,2]`     | `[1,5,2,2]`     | 3      |
| `[1,2,3,4,5]`   | `[1,2,3,4,5]`   | 5      |

------

##### 입출력 예 설명

입출력 예 #1

- 본문의 예시와 같습니다.

입출력 예 #2

- 다음 표와 같이 2번 문제부터의 영역을 밀려 쓰기로 인정할 경우, 최대 3문제를 맞힐 수 있습니다.

| 문제 번호             | 1번  | 2번       | 3번       | 4번           | 맞춘 문제 개수        |
| --------------------- | ---- | --------- | --------- | ------------- | --------------------- |
| 정답지                | 1    | 5         | 2         | 2             |                       |
| 원래 OMR 답안지       | 1    | 3         | 5         | 2             | 2문제 (1번, 4번)      |
| 2번부터 밀려쓰기 인정 | 1    | ~~3~~ → 5 | ~~5~~ → 2 | ~~2~~ -> 공란 | 3문제 (1번, 2번, 3번) |

입출력 예 #3

- 그대로 채점해도 모든 문제를 맞힐 수 있으므로, 별도의 영역을 지정해 밀려 쓰기를 인정할 필요가 없습니다.



##### 소스코드

```c++
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> marks, vector<int> answers) {
    int answer = 0;
    int i, j, cnt;

    marks.push_back(0);
    for(i=0; i<=answers.size(); i++){
        cnt = 0;
        for(j=0; j<answers.size(); j++){
            if(j < i) cnt += marks[j] == answers[j];
            else cnt += marks[j+1] == answers[j];
        }

        answer = max(answer, cnt);
    }

    return answer;
}
```



# 2번

###### 문제 설명

숫자 블록으로 이루어진 피라미드가 있습니다. 각 블록에는 숫자가 적혀있는데, 어떤 블록의 값은 바로 아래에 맞닿아 있는 두 블록의 값을 합한 값입니다. 피라미드의 일부 블록 값이 주어졌을 때 전체 피라미드 구성을 알아내려고 합니다.

아래 그림은 피라미드를 구성하는 일부 블록의 값을 나타냅니다.

![example0_start.png](C:\Users\SAMSUNG\Desktop\프로그래머스\img\example0_start.png)

각 층마다 1개의 블록 값을 알기 때문에 다음과 같이 모든 피라미드의 블록 값을 알아낼 수 있습니다.

![example0_end.png](C:\Users\SAMSUNG\Desktop\프로그래머스\img\example0_end.png)

피라미드의 꼭대기 층인 0행부터 마지막 행까지 순서대로, 각 행을 구성하는 블록들 중 하나에 대한 정보를 나타내는 2차원 배열 blocks가 매개변수로 주어집니다. 피라미드를 완성시킨 후, 꼭대기 층 왼쪽부터 제일 아래층 오른쪽까지 순서대로 모두 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- blocks의 길이는 1 이상 15 이하입니다.
  - blocks의 i번째 원소는 피라미드 i행을 구성하는 블록 하나에 대한 정보입니다.
  - blocks의 원소는 [a, b] 형식입니다.
  - a는 왼쪽에서 몇 번째 블록인지를 나타내며(맨 왼쪽의 블록이 0번째 블록입니다), i행의 경우 0 이상 i 이하의 정수입니다.
  - b는 블록의 값을 나타내며, -100 이상 100 이하의 정수입니다.

------

##### 입출력 예

| blocks                                           | result                                                       |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `[[0, 50], [0, 22], [2, 10], [1, 4], [4, -13]]`  | `[50, 22, 28, 4, 18, 10, 0, 4, 14, -4, 1, -1, 5, 9, -13]`    |
| `[[0, 92], [1, 20], [2, 11], [1, -81], [3, 98]]` | `[92, 72, 20, 63, 9, 11, 144, -81, 90, -79, 217, -73, -8, 98, -177]` |

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
아래 그림과 같이 피라미드를 채울 수 있습니다.

![example1_end.png](C:\Users\SAMSUNG\Desktop\프로그래머스\img\example1_end.png)



##### 소스코드

```python
def solution(blocks):
    answer = [blocks[0][1]]

    pyramid = []

    for i in range(len(blocks)):
        pyramid.append([0]*(i+1))
        
        pyramid[i][blocks[i][0]] = blocks[i][1]

        if(i == 0): continue
        for j in range(blocks[i][0]-1, -1, -1):
            pyramid[i][j] = pyramid[i-1][j] - pyramid[i][j+1]
        for j in range(blocks[i][0]+1, i+1):
            pyramid[i][j] = pyramid[i-1][j-1] - pyramid[i][j-1]
        
        answer += pyramid[i]

    return answer
```







# 3번

###### 문제 설명

미니 테트리스는 테트리스와 유사한 게임으로, 규칙이 약간 다릅니다. 이 게임에서 등장하는 모든 블록은 높이가 1인 가로 일자형 블록이며, 회전할 수 없습니다. 블록은 위에서부터 아래로 내려오며 보드 공간의 가장 낮은 층부터 쌓입니다. 주어진 블록을 모두 쌓았을 때 그 높이를 최대한 낮추는 것이 게임의 목표입니다. 단, 미니 테트리스는 보드 공간의 한층이 블록으로 꽉 차더라도 그 층을 지우지는 않습니다.

당신은 게임에서 승리하기 위해 다음과 같은 간단한 알고리즘을 사용합니다.

- 보드 공간의 가장 낮은 층의 왼쪽부터 블록을 쌓습니다.
- 내려오는 블록의 길이보다 보드 공간의 어떤 층 오른쪽에 남은 공간이 더 작아서 통과할 수 없다면, 그 층위에 블록을 쌓습니다.

보드의 가로길이 m과 내려올 블록의 길이가 순서대로 들어 있는 배열 v가 매개변수로 주어집니다. 위의 알고리즘을 따라 블록을 쌓았을 때, 쌓인 블록의 층 수를 return 하도록 solution 함수를 완성해주세요.

##### 제한 사항

- m은 1 이상 1,000 이하인 자연수입니다.
- 배열 v의 길이는 1 이상 100,000 이하입니다.
- 배열 v의 원소는 1 이상 m 이하인 자연수입니다.

##### 입출력 예

| m    | v         | result |
| ---- | --------- | ------ |
| 4    | [2,3,1]   | 2      |
| 4    | [3,2,3,1] | 3      |

##### 입출력 예 설명

입출력 예 #1
보드의 가로길이가 4이고, 길이가 2, 3, 1인 블록이 차례로 내려옵니다. 첫 번째 블록은 1층에 쌓입니다(가장 낮은 층이 1층입니다). 두 번째 블록은 길이가 3이고 1층의 남은 공간이 2이기 때문에 1층에 쌓이지 못하고 2층에 쌓입니다. 세 번째 블록은 길이가 1이기 때문에 2층을 통과하고 1층으로 내려가서 왼쪽으로 이동합니다.
아래 그림은 블록을 쌓는 과정을 나타냅니다.

![tetris1.png](C:\Users\SAMSUNG\Desktop\프로그래머스\img\tetris1.png)

총 2개 층이 쌓였기 때문에 2를 return 합니다.

입출력 예 #2
보드의 가로길이가 4이고, 길이가 3, 2, 3, 1인 블록이 차례로 내려옵니다. 첫 번째 블록이 1층에 쌓입니다. 두 번째 블록은 길이가 2이고 1층의 남은 공간이 1이기 때문에 1층에 쌓이지 못하고 2층에 쌓입니다. 세 번째 블록은 길이가 3이기 때문에 2층을 통과하지 못하고 3층에 쌓입니다. 네 번째 블록은 길이가 1이므로 3층과 2층을 통과하여 1층에 쌓입니다. 1층이 꽉 찼지만, 블록을 지우지 않습니다.
아래 그림은 블록을 쌓는 과정을 나타냅니다.

![tetris2.png](C:\Users\SAMSUNG\Desktop\프로그래머스\img\tetris2.png)

총 3개 층이 쌓였기 때문에 3을 return 합니다.



##### 소스코드

```python
def solution(m, v):
    answer = 0

    stack = [m, 0]
    for l in v:
        for j in range(len(stack)-1, -1, -1):
            if l > m-stack[j]:
                stack[j+1] += l
                break

        if stack[-1] != 0:
            stack.append(0)

    return len(stack)-2
```

